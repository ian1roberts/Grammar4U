<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Coding Grammarly — Local Writing Assistant</title>
<style>
  :root{
    --muted:#8a97b1; --text:#e7ecf5; --accent:#88aaff; --accent2:#57d3a0;
    --warn:#f7b955; --error:#ff6b6b; --shadow:0 10px 25px rgba(0,0,0,.35); --r:16px;
    --panel:#0f1424; --card:#12172a; --success:#57d3a0;
  }
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;background:#0b0e14;color:var(--text);font:500 15px/1.55 Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  header{position:fixed;top:0;left:0;right:0;z-index:20;background:rgba(10,14,22,.7);backdrop-filter:saturate(140%) blur(8px);border-bottom:1px solid #1c2235}
  .bar{max-width:1200px;margin:auto;display:flex;align-items:center;gap:12px;padding:12px 16px}
  .logo{display:flex;align-items:center;gap:10px;font-weight:800;letter-spacing:.2px}
  .dot{width:10px;height:10px;border-radius:50%;background:var(--accent2);box-shadow:0 0 16px var(--accent2)}
  .pill{display:inline-flex;align-items:center;gap:8px;background:#0f1424;color:var(--muted);border:1px solid #1e2740;padding:8px 10px;border-radius:12px}
  .pill input,.pill select{background:transparent;border:none;outline:none;color:var(--text);font-weight:600}
  .pill select{background:#f8f9fa;color:#212529;border:1px solid #ced4da;border-radius:6px;padding:4px 8px}
  .pill select option{background:#ffffff;color:#212529}
  .pill select:focus{outline:2px solid var(--accent);outline-offset:2px}
  .pill .status-indicator{font-size:12px;padding:4px 8px;border-radius:6px;font-weight:600}
  .pill .status-indicator.success{background:#d1e7dd;color:#0f5132;border:1px solid #badbcc}
  .pill .status-indicator.error{background:#f8d7da;color:#842029;border:1px solid #f5c2c7}
  .btn{appearance:none;border:none;background:#1a2040;color:#cfe1ff;padding:10px 14px;border-radius:12px;box-shadow:var(--shadow);cursor:pointer;transition:.15s transform,.2s background}
  .btn:hover{transform:translateY(-1px);background:#232a52}
  .btn.ghost{background:transparent;border:1px dashed #2b3560;color:#c2d1ff}
  .btn.accent{background:linear-gradient(135deg,#6489ff,#7fd9bf);color:#081022}
  .wrap{max-width:1200px;margin:120px auto 18px auto;padding:0 16px;display:grid;grid-template-columns:1.1fr .9fr;gap:16px}
  .editor,.side{background:var(--panel);border:1px solid #1b2136;border-radius:var(--r);box-shadow:var(--shadow)}
  .toolbar{padding:10px;display:flex;flex-wrap:wrap;gap:8px;border-bottom:1px solid #1b2238;background:#0f1424;border-top-left-radius:var(--r);border-top-right-radius:var(--r)}
  textarea{width:100%;min-height:360px;resize:vertical;padding:18px;background:transparent;color:var(--text);border:none;outline:none;font:500 16px/1.6 ui-serif,Georgia,"Times New Roman",serif}
  .metrics{display:flex;gap:14px;padding:10px 14px;border-top:1px solid #1b2238;color:var(--muted);flex-wrap:wrap}
  .chip{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;background:#12172a;border:1px solid #1e2740;border-radius:999px}
  .tabs{display:flex;gap:6px;padding:10px;border-bottom:1px solid #1a2036;background:#0f1424;border-top-left-radius:var(--r);border-top-right-radius:var(--r)}
  .panel{padding:12px 10px 14px 10px;display:none}.panel.active{display:block}
  .card{background:var(--card);border:1px solid #1d2340;border-radius:14px;padding:12px;margin:10px 6px}
  .card h4{margin:0 0 8px 0;font-size:14px}
  .card p{margin:0 0 10px 0;color:#cdd7f0}
  .suggestion{border-left:3px solid var(--accent);padding-left:10px;margin-left:2px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .kbd{background:#0e1322;border:1px solid #223058;padding:0 6px;border-radius:6px;font-size:12px}
  .foot{display:flex;justify-content:space-between;align-items:center;color:var(--muted);padding:12px 16px;border-top:1px solid #1b2136}
  mark.add{background:rgba(127,217,191,.2);outline:1px solid rgba(127,217,191,.45)}
  mark.remove{background:rgba(255,107,107,.18);outline:1px solid rgba(255,107,107,.45);text-decoration:line-through}
  mark.warn{background:rgba(247,185,85,.18);outline:1px solid rgba(247,185,85,.5)}
  .toast{position:fixed;right:16px;bottom:16px;background:#0f1424;border:1px solid #263054;color:#cfe1ff;padding:10px 12px;border-radius:12px;box-shadow:var(--shadow);opacity:0;transform:translateY(10px);transition:.2s}
  .toast.show{opacity:1;transform:translateY(0)}
  .subtle{color:var(--muted);font-size:13px}
  .badge{background:#101833;border:1px solid #263054;padding:2px 8px;border-radius:999px;font-size:12px;color:#b7c6f3}
  @media (max-width:980px){.wrap{grid-template-columns:1fr}}

.overlay {
  position: fixed; inset: 0; display: none; place-items: center;
  background: rgba(8,12,20,.55); backdrop-filter: blur(4px);
  z-index: 1000; color: #cfe1ff;
}
.overlay.show { display: grid; }
.overlay .card {
  background:#0f1424; border:1px solid #263054; border-radius:14px;
  padding:14px 16px; box-shadow:0 10px 25px rgba(0,0,0,.35);
  display:flex; align-items:center; gap:12px; max-width: 90vw;
}
.spinner {
  width:18px; height:18px; border-radius:50%;
  border:3px solid #2b3560; border-top-color:#88aaff;
  animation: spin 0.9s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
.dim .btn, .dim input, .dim select, .dim textarea { pointer-events:none; opacity:.6 }

</style>
</head>
<body>
<header>
  <div class="bar">
    <div class="logo"><span class="dot"></span> Coding Grammarly <span class="badge">Local</span></div>
    <div class="pill"><span>API Key</span><span id="apiKeyStatus" class="status-indicator">Checking...</span></div>
    <div class="pill"><span>Model</span>
      <select id="model">
        <option>gpt-4o-mini</option>
        <option>gpt-4.1-mini</option>
        <option>gpt-4o</option>
        <option>gpt-4.1</option>
      </select>
      <button id="refreshModels" class="btn ghost" style="margin-left:8px;padding:6px 10px;font-size:12px" title="Refresh available models from API">↻</button>
      <span id="cacheStatus" class="status-indicator" style="margin-left:8px;color:var(--success);font-size:11px" title="Prompt caching enabled to reduce API costs">⚡ Cached</span>
    </div>
    <div class="pill"><span>Endpoint</span><input id="endpoint" placeholder="http://localhost:3333" style="width:230px"></div>
    <label class="pill" title="If off, runs in on-device demo mode"><input id="useLLM" type="checkbox"> Use OpenAI</label>
    <button id="saveSettings" class="btn">Save settings</button>
  </div>
</header>

<main class="wrap">
  <section class="editor">
    <div class="toolbar">
      <button class="btn" id="checkAll">Check <span class="kbd">Ctrl</span>+<span class="kbd">Enter</span></button>
      <button class="btn ghost" id="applyAll">Apply all</button>
      <button class="btn ghost" id="undoBtn">Undo last</button>
      <div style="flex:1"></div>
      <button class="btn ghost" id="pasteBtn">Paste (clean)</button>
      <button class="btn" id="rewriteSimple">Rewrite: Simplify</button>
      <button class="btn" id="rewriteFormal">Rewrite: Formal</button>
      <button class="btn" id="rewriteFriendly">Rewrite: Friendly</button>
      <div style="flex:1"></div>
      <button class="btn" id="copyBtn">Copy</button>
      <button class="btn" id="exportBtn">Export .md</button>
      <button class="btn accent" id="clearBtn">Clear</button>
    </div>
    <textarea id="input" spellcheck="false" placeholder="Paste or type your text here. Press Ctrl+Enter to analyse."></textarea>
    <div class="metrics" id="metrics"></div>
  </section>

  <aside class="side">
    <div class="tabs">
      <button class="btn ghost" data-tab="grammar">Grammar</button>
      <button class="btn ghost" data-tab="clarity">Clarity</button>
      <button class="btn ghost" data-tab="tone">Tone</button>
      <button class="btn ghost" data-tab="rewrite">Rewrite</button>
    </div>
    <div class="panel active" id="panel-grammar"></div>
    <div class="panel" id="panel-clarity"></div>
    <div class="panel" id="panel-tone"></div>
    <div class="panel" id="panel-rewrite"></div>
    <div class="foot">
      <div>Tips: Select a suggestion to preview, then “Apply fix”.</div>
      <div class="subtle">Local heuristics + optional LLM analysis</div>
    </div>
  </aside>
</main>

<div id="toast" class="toast" role="status"></div>

<script>
/* ===================== Utilities & State ===================== */
const $ = (q) => document.querySelector(q);
const $$ = (q) => Array.from(document.querySelectorAll(q));

const LS = {
  get(k, d = null) {
    try {
      return JSON.parse(localStorage.getItem(k)) ?? d;
    } catch {
      return d;
    }
  },
  set(k, v) {
    localStorage.setItem(k, JSON.stringify(v));
  }
};

const state = {
  useLLM: false,
  apiKey: "",
  model: "gpt-4o-mini",
  endpoint: "http://localhost:3333",
  lastText: "",
  undoStack: [],
  suggestions: {
    grammar: [],
    clarity: [],
    tone: [],
    rewrite: []
  }
};

function toast(msg, ms = 1800) {
  const t = $('#toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), ms);
}

function saveSettings() {
  const oldEndpoint = state.endpoint;
  
  state.model = $('#model').value;
  state.endpoint = $('#endpoint').value.trim() || 'http://localhost:3333';
  state.useLLM = $('#useLLM').checked;
  
  LS.set('cg_settings_v2', {
    model: state.model,
    endpoint: state.endpoint,
    useLLM: state.useLLM
  });
  
  // Refresh models and check API key if endpoint changed
  if (state.endpoint !== oldEndpoint) {
    checkApiKeyAvailability().then(() => {
      return populateModelDropdown();
    }).then(() => {
      toast('Settings saved, models updated');
    }).catch(() => {
      toast('Settings saved');
    });
  } else {
    toast('Settings saved');
  }
}

function loadSettings() {
  const s = LS.get('cg_settings_v2', null);
  if (!s) return;
  
  $('#model').value = s.model || "gpt-4o-mini";
  $('#endpoint').value = s.endpoint || "http://localhost:3333";
  $('#useLLM').checked = !!s.useLLM;
  
  // Update state (excluding apiKey which comes from environment)
  state.model = s.model || "gpt-4o-mini";
  state.endpoint = s.endpoint || "http://localhost:3333";
  state.useLLM = !!s.useLLM;
}

/* ===================== Text Normalisation & Metrics ===================== */
function normaliseText(t){
  // Clean odd paste artefacts but keep meaning intact.
  return t
    .replace(/\r\n?/g, '\n')                  // CRLF → LF
    .replace(/\u00A0/g, ' ')                  // nbsp → space
    .replace(/[ \t]+\n/g, '\n')               // trim line-end spaces
    .replace(/[“”]/g, '"').replace(/[‘’]/g,"'"); // smart quotes → ASCII
}
function setText(t){
  const ta=$('#input'); state.undoStack.push(ta.value);
  ta.value=t; updateMetrics();
}
function undo(){ const prev=state.undoStack.pop(); if(prev!=null){ $('#input').value=prev; updateMetrics(); toast('Undid last change'); } }
function fleschReadingEase(text){
  const sentences=Math.max(1,(text.match(/[.!?]+/g)||[]).length);
  const words = Math.max(1, (text.trim().split(/\s+/) || []).filter(Boolean).length);
  const syllables = text.toLowerCase().split(/\b/).reduce((a, w) => 
    /^[a-z]+$/.test(w) 
      ? a + Math.max(1, (w.replace(/e\b/g, '').match(/[aeiouy]+/g) || []).length) 
      : a, 0
  );
  const score = 206.835 - (1.015 * (words / sentences)) - (84.6 * (syllables / words));
  return Math.max(0, Math.min(100, Math.round(score)));
}

function updateMetrics() {
  const t = $('#input').value;
  const words = (t.trim().match(/\S+/g) || []).length;
  const chars = t.length;
  const minutes = Math.max(1, Math.round(words / 200));
  const readingEase = fleschReadingEase(t);
  
  $('#metrics').innerHTML = `
    <span class="chip">Words: <b>${words}</b></span>
    <span class="chip">Characters: <b>${chars}</b></span>
    <span class="chip">Reading time: <b>${minutes} min</b></span>
    <span class="chip">Flesch: <b>${readingEase}</b></span>`;
}

/* ===================== Heuristics (with precise ranges) ===================== */
function mksug({id,type,severity,message,start,end,fixText,previewHtml}){
  return { id,type,severity,message,start,end,fixText, preview:(s)=>previewHtml ?? escapeHtml(s.slice(Math.max(0,start-40), end+40)) };
}
function findRepeats(text){
  const out=[]; let m; const re=/\b(\w+)\s+(\1)\b/gi;
  while((m=re.exec(text))){ const [span,w1,w2]=m;
    out.push(mksug({ id:`repeat-${m.index}`, type:'grammar', severity:'medium',
      message:`Repeated word: “${w1} ${w2}”`, start:m.index, end:m.index+span.length,
      fixText:w1, previewHtml: `${escapeHtml(span).replace(/ /,' ')} → <mark class="remove">${escapeHtml(span)}</mark> <mark class="add">${escapeHtml(w1)}</mark>` }));
  } return out;
}
function findSpaces(text) {
  const out = [];
  let m;
  const re = /([^\S\r\n]{2,})/g;
  
  while ((m = re.exec(text))) {
    out.push(mksug({
      id: `space-${m.index}`,
      type: 'grammar',
      severity: 'low',
      message: 'Multiple spaces detected',
      start: m.index,
      end: m.index + m[0].length,
      fixText: ' ',
      previewHtml: `<mark class="remove">${escapeHtml('·'.repeat(m[0].length))}</mark> → <mark class="add">${escapeHtml('·')}</mark>`
    }));
  }
  return out;
}
function britSpelling(text){
  const pairs=[['color','colour'],['organize','organise'],['analyze','analyse'],['favor','favour'],['center','centre']];
  const out=[]; pairs.forEach(([us,uk])=>{
    const re=new RegExp(`\\b${us}\\b`,'gi'); let m;
    while((m=re.exec(text))){
      out.push(mksug({ id:`brit-${m.index}-${us}`, type:'grammar', severity:'low',
        message:`Prefer British “${uk}” over “${m[0]}”`, start:m.index, end:m.index+m[0].length, fixText:uk,
        previewHtml:`<mark class="remove">${m[0]}</mark> → <mark class="add">${uk}</mark>` }));
    }
  }); return out;
}
function oxfordComma(text) {
  const out = [];
  const re = /\b([A-Za-z]{2,})(, [A-Za-z]{2,})+ and [A-Za-z]{2,}\b/g;
  let m;
  
  while ((m = re.exec(text))) {
    const span = m[0];
    if (span.includes(', and')) continue;
    
    out.push(mksug({
      id: `ox-${m.index}`,
      type: 'clarity',
      severity: 'low',
      message: 'Consider Oxford comma',
      start: m.index,
      end: m.index + span.length,
      fixText: span.replace(' and', ', and'),
      previewHtml: `${escapeHtml(span).replace(' and', ' <mark class="add">,</mark> and')}`
    }));
  }
  return out;
}
function passiveVoice(text){
  const out=[]; const re=/\b(?:is|was|were|been|being|are|be)\s+\w+ed\b/gi; let m; let c=0;
  while((m=re.exec(text)) && c<12){ c++; out.push(mksug({ id:`pass-${m.index}`, type:'tone', severity:'low',
    message:`Possible passive voice: “${m[0]}”`, start:m.index, end:m.index+m[0].length, fixText:null,
    previewHtml:`<mark class="warn">${m[0]}</mark>` })); } return out;
}
function runHeuristics(text){
  return {
    grammar:[...findRepeats(text), ...findSpaces(text), ...britSpelling(text)],
    clarity:[...oxfordComma(text)],
    tone:[...passiveVoice(text)]
  };
}

/* ===================== OpenAI integration ===================== */
async function checkApiKeyAvailability() {
  const statusEl = $('#apiKeyStatus');
  const { endpoint } = state;
  
  if (!endpoint) {
    updateApiKeyStatus('error', 'No endpoint configured');
    return false;
  }

  try {
    // Try to fetch models as a way to test API key availability
    // This will work whether the key is from env, local storage, or other sources
    statusEl.textContent = 'Checking...';
    statusEl.className = 'status-indicator';
    
    const res = await fetch(endpoint.replace(/\/$/,'') + '/v1/models', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
        // Note: Not setting Authorization header - let the server/proxy handle it from env
      }
    });

    if (res.ok) {
      updateApiKeyStatus('success', 'Available via proxy');
      state.apiKey = 'loaded-from-proxy'; // Indicator that key is available
      return true;
    } else {
      const errorText = await res.text().catch(() => 'Unknown error');
      if (res.status === 401) {
        updateApiKeyStatus('error', 'Proxy: API key missing');
      } else if (res.status === 404) {
        updateApiKeyStatus('error', 'Proxy: Endpoint missing');
      } else {
        updateApiKeyStatus('error', `Proxy: Error ${res.status}`);
      }
      console.warn('API key check failed:', res.status, errorText);
      throw new Error(`API returned ${res.status}: ${errorText}`);
    }
  } catch (error) {
    console.warn('API key check failed:', error);
    if (error.message.includes('Failed to fetch') || error.message.includes('fetch')) {
      updateApiKeyStatus('error', 'Proxy unreachable');
    } else {
      updateApiKeyStatus('error', 'Check failed');
    }
    state.apiKey = '';
    return false;
  }
}

function updateApiKeyStatus(type, message) {
  const statusEl = $('#apiKeyStatus');
  statusEl.textContent = message;
  statusEl.className = `status-indicator ${type}`;
}

async function fetchAvailableModels() {
  const { endpoint } = state;
  if (!endpoint) {
    console.warn('No endpoint configured, using default models');
    return null;
  }

  try {
    setBusy('Fetching available models...');
    const res = await fetch(endpoint.replace(/\/$/,'') + '/v1/models', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json'
        // API key should be handled by server/proxy from environment
      }
    });

    if (!res.ok) {
      throw new Error(`Failed to fetch models: ${res.status}`);
    }

    const data = await res.json();
    
    // Filter for chat/completion models (GPT models)
    const chatModels = data.data
      .filter(model => model.id.includes('gpt') || model.id.includes('o1'))
      .sort((a, b) => {
        // Prioritize newer models
        const priority = {
          'gpt-4o': 1,
          'gpt-4o-mini': 2,
          'gpt-4-turbo': 3,
          'gpt-4': 4,
          'gpt-3.5-turbo': 5
        };
        
        const aPriority = Object.keys(priority).find(key => a.id.includes(key)) || 999;
        const bPriority = Object.keys(priority).find(key => b.id.includes(key)) || 999;
        
        return (priority[aPriority] || 999) - (priority[bPriority] || 999);
      });

    return chatModels;
  } catch (error) {
    console.error('Error fetching models:', error);
    toast('Failed to fetch models, using defaults');
    return null;
  } finally {
    clearBusy();
  }
}

async function populateModelDropdown() {
  const modelSelect = $('#model');
  const currentValue = modelSelect.value;
  
  // Default models as fallback
  const defaultModels = [
    { id: 'gpt-4o', name: 'GPT-4o' },
    { id: 'gpt-4o-mini', name: 'GPT-4o Mini' },
    { id: 'gpt-4-turbo', name: 'GPT-4 Turbo' },
    { id: 'gpt-4', name: 'GPT-4' },
    { id: 'gpt-3.5-turbo', name: 'GPT-3.5 Turbo' }
  ];

  let modelsToUse = defaultModels;
  
  // Try to fetch from API if endpoint is configured
  if (state.endpoint) {
    const fetchedModels = await fetchAvailableModels();
    if (fetchedModels && fetchedModels.length > 0) {
      modelsToUse = fetchedModels.map(model => ({
        id: model.id,
        name: model.id.replace(/^gpt-/, 'GPT-').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())
      }));
    }
  }

  // Clear existing options
  modelSelect.innerHTML = '';
  
  // Populate with models
  modelsToUse.forEach(model => {
    const option = document.createElement('option');
    option.value = model.id;
    option.textContent = model.name;
    modelSelect.appendChild(option);
  });

  // Restore previous selection if it exists, otherwise use first option
  if (modelsToUse.find(m => m.id === currentValue)) {
    modelSelect.value = currentValue;
  } else {
    modelSelect.value = modelsToUse[0].id;
    state.model = modelsToUse[0].id;
  }
}

async function callOpenAIChat(body){
  const { endpoint } = state;
  if(!endpoint) throw new Error('Missing endpoint');
  setBusy('LLM query sent, waiting for response …');
  try{
    const res = await fetch(endpoint.replace(/\/$/,'') + '/v1/chat/completions', {
      method:'POST',
      headers:{
        'Content-Type':'application/json'
        // API key should be handled by server/proxy from environment
      },
      body: JSON.stringify(body)
    });
    if(!res.ok){
      const txt = await res.text();
      throw new Error(`OpenAI error ${res.status}: ${txt}`);
    }
    const data = await res.json();
    return data.choices?.[0]?.message?.content?.trim() || '';
  } finally {
    clearBusy();
  }
}

async function llmAnalyse(text) {
  // For long text, analyse in chunks (8k chars each) and merge.
  const chunks=[]; const CH=8000;
  for(let i=0;i<text.length;i+=CH) chunks.push(text.slice(i,i+CH));
  const results=[];
  
  // Cache the system prompt to reduce costs on repeated requests
  const cachedSystemPrompt = {
    role: 'system', 
    content: 'You are a meticulous British-English copy editor. Return STRICT JSON: {"grammar":[],"clarity":[],"tone":[]}. Each array contains edits as {"message":str,"start":int,"end":int,"replacement":str|null}. Indices refer to the given text.',
    cache_control: { type: "ephemeral" }
  };
  
  for(const [idx,chunk] of chunks.entries()){
    const content = await callOpenAIChat({
      model: state.model,
      response_format: { type: "json_object" },
      temperature: 0.1,
      messages: [
        cachedSystemPrompt,
        {role:'user', content: `Text (chunk ${idx+1}/${chunks.length}):\n${chunk}`}
      ]
    });
    
    let json;
    try {
      json = JSON.parse(content);
      // Validate the expected structure
      if (!json.grammar || !json.clarity || !json.tone) {
        console.warn('LLM returned invalid structure, using empty arrays');
        json = { grammar: [], clarity: [], tone: [] };
      }
    } catch (parseError) {
      console.error('Failed to parse LLM response:', parseError, 'Raw content:', content);
      json = { grammar: [], clarity: [], tone: [] };
    }
    
    results.push({json, offset: idx*CH});
  }
  // Merge with offsets
  const out = { grammar:[], clarity:[], tone:[] };
  for(const r of results){
    ['grammar','clarity','tone'].forEach(k=>{
      (r.json[k]||[]).forEach(e=>{
        // Validate each suggestion object
        if (!e || typeof e.message !== 'string' || typeof e.start !== 'number' || typeof e.end !== 'number') {
          console.warn('Invalid LLM suggestion object:', e);
          return;
        }
        
        out[k].push({
          id:`llm-${k}-${r.offset}-${e.start}-${e.end}`,
          type:k, severity:'medium', message:e.message,
          start:e.start + r.offset, end:e.end + r.offset, fixText:e.replacement,
          preview:(s)=> e.replacement!=null
            ? `${escapeHtml(s.slice(e.start+r.offset, e.end+r.offset))} → <mark class="add">${escapeHtml(e.replacement)}</mark>`
            : 'Review and edit manually.'
        });
      });
    });
  }
  return out;
}
async function llmRewrite(fullText, mode){
  const style = {
    simplify: "Rewrite to be clearer and simpler without losing meaning. Short sentences; plain British English.",
    formal: "Rewrite in a formal, professional register suitable for a business report in British English.",
    friendly: "Rewrite to sound warm and friendly while staying concise in British English."
  }[mode];
  
  // Cache the system prompt to reduce costs on repeated requests
  const cachedSystemPrompt = {
    role: 'system', 
    content: 'You are a careful British-English editor. Preserve meaning precisely.',
    cache_control: { type: "ephemeral" }
  };
  
  const content = await callOpenAIChat({
    model: state.model,
    temperature: 0.25,
    messages: [
      cachedSystemPrompt,
      {role:'user', content:`${style}\n\nText:\n"""${fullText}"""`}
    ]
  });
  return content;
}

/* ===================== Rendering & Application ===================== */
function renderSuggestions(){
  const areas=[
    ['grammar','#panel-grammar','Grammar & Punctuation'],
    ['clarity','#panel-clarity','Clarity'],
    ['tone','#panel-tone','Tone'],
    ['rewrite','#panel-rewrite','Rewrite']
  ];
  areas.forEach(([key,sel,title])=>{
    const box=$(sel); const items=state.suggestions[key]||[];
    box.innerHTML=`<div class="card"><h4>${title}</h4><p class="subtle">${items.length?`Found ${items.length} ${items.length===1?'suggestion':'suggestions'}.`:'No suggestions yet — press “Check”.'}</p></div>`;
    items.forEach(s=>{
      const card=document.createElement('div'); card.className='card suggestion';
      const sevColor=s.severity==='low'?'var(--muted)':(s.severity==='medium'?'var(--warn)':'var(--error)');
      card.innerHTML=`
        <div class="row" style="justify-content:space-between">
          <div style="font-weight:700">${escapeHtml(s.message||'Suggestion')}</div>
          <span class="badge" style="border-color:${sevColor};color:${sevColor}">${s.severity||'medium'}</span>
        </div>
        <div class="preview" style="margin:8px 0;padding:8px;background:#0f1424;border:1px solid #1f2a49;border-radius:10px;overflow:auto;max-height:160px"></div>
        <div class="row">
          <button class="btn" data-action="apply">Apply fix</button>
          <button class="btn ghost" data-action="select">Select range</button>
        </div>`;
      const prev=card.querySelector('.preview');
      try{ prev.innerHTML = typeof s.preview==='function' ? safePreview(s.preview($('#input').value)) : '—'; }
      catch{ prev.textContent='—'; }
      card.querySelector('[data-action="apply"]').onclick=()=>applySuggestion(s);
      card.querySelector('[data-action="select"]').onclick=()=>selectRange(s);
      box.appendChild(card);
    });
  });
}
function applySuggestion(sug){
  const ta=$('#input'); const t=ta.value;
  if(typeof sug.start==='number' && typeof sug.end==='number' && sug.fixText!=null){
    setText(t.slice(0,sug.start)+sug.fixText+t.slice(sug.end));
    ta.focus(); ta.setSelectionRange(sug.start, sug.start + sug.fixText.length);
    analyseDebounced();
    toast('Applied fix');
  }else{
    toast('No automatic fix; edit manually');
  }
}
function selectRange(sug){
  if(typeof sug.start!=='number' || typeof sug.end!=='number'){ toast('No selection data'); return; }
  const ta=$('#input'); ta.focus(); ta.setSelectionRange(sug.start, Math.min(sug.end, ta.value.length)); toast('Selected');
}
function applyAll(){
  const ta=$('#input'); let t=ta.value; const edits=[];
  const all=[...state.suggestions.grammar, ...state.suggestions.clarity, ...state.suggestions.tone].filter(s=>s.fixText!=null);
  // Apply from end to start to keep indices stable
  all.sort((a,b)=>b.start-a.start).forEach(s=>{ edits.push([s.start,s.end,s.fixText]); t=t.slice(0,s.start)+s.fixText+t.slice(s.end); });
  if(edits.length===0){ toast('Nothing to apply'); return; }
  setText(t); analyseDebounced(); toast(`Applied ${edits.length} fixes`);
}

/* ===================== Analyse & Rewrite ===================== */
let analyseTimer=null;
function analyseDebounced(){ clearTimeout(analyseTimer); analyseTimer=setTimeout(analyse, 160); }
async function analyse(){
  const raw=$('#input').value;
  const text=normaliseText(raw);
  if(text!==raw){ setText(text); }
  state.lastText = text;

  // Local heuristics
  const heur = runHeuristics(text);
  state.suggestions.grammar = heur.grammar;
  state.suggestions.clarity = heur.clarity;
  state.suggestions.tone = heur.tone;

  // Optional LLM
  if(state.useLLM){
    try{
      const llm = await llmAnalyse(text);
      // Merge (keep heuristics, append LLM)
      ['grammar','clarity','tone'].forEach(k=> state.suggestions[k].push(...llm[k]));
    }catch(e){
      console.warn(e); toast('LLM analysis failed; showing local checks');
    }
  }
  renderSuggestions();
}
async function doRewrite(mode){
  const text=$('#input').value.trim();
  if(!text){ toast('Nothing to rewrite'); return; }
  if(state.useLLM){
    try{
      const out = await llmRewrite(text, mode);
      if(out && out.length>0){ setText(out); analyseDebounced(); toast('Rewritten'); return; }
    }catch(e){ console.warn(e); toast('LLM rewrite failed; using demo rewrite'); }
  }
  // Fallback demo
  let out=text;
  if(mode==='simplify'){
    out=out.replace(/\butilise\b/gi,'use').replace(/\bapproximately\b/gi,'about').replace(/\bsubsequently\b/gi,'then').replace(/\bcommence\b/gi,'start');
  }else if(mode==='formal'){
    out=out.replace(/\b(very|really|quite|sort of|kind of)\b/gi,'').replace(/\bgot\b/gi,'received').replace(/\bhelp\b/gi,'assist').replace(/\bfix\b/gi,'resolve');
  }else if(mode==='friendly'){
    out=out.replace(/\bhowever\b/gi,'but').replace(/\btherefore\b/gi,'so').replace(/\bnevertheless\b/gi,'still');
  }
  setText(out); analyseDebounced(); toast('Demo rewrite complete');
}

/* ===================== Export / Copy / Paste ===================== */
function exportMarkdown(){
  const text=$('#input').value; const blob=new Blob([text],{type:'text/markdown;charset=utf-8'});
  const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='draft.md'; a.click(); URL.revokeObjectURL(url); toast('Exported as draft.md');
}
function copyToClipboard(){
  navigator.clipboard?.writeText($('#input').value).then(()=>toast('Copied')).catch(()=>{ const t=$('#input'); t.select(); document.execCommand('copy'); toast('Copied'); });
}
async function pasteClean(){
  try{
    const txt = await navigator.clipboard.readText();
    if(!txt){ toast('Clipboard is empty'); return; }
    const clean=normaliseText(txt);
    setText(clean);
    analyseDebounced();
    toast('Pasted & cleaned');
  }catch(e){
    toast('Clipboard blocked by browser');
  }
}

/* ===================== Helpers ===================== */
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
function safePreview(html){
  const t=document.createElement('template'); t.innerHTML=html;
  t.content.querySelectorAll('*').forEach(el=>{
    if(el.tagName==='MARK'){
      const cls=el.className||''; if(!/^(add|remove|warn)$/.test(cls)) el.removeAttribute('class');
      Array.from(el.attributes).forEach(a=>{ if(a.name!=='class') el.removeAttribute(a.name); });
    }else{ const text=document.createTextNode(el.textContent); el.replaceWith(text); }
  });
  return t.innerHTML;
}

/* ===================== Events & Init ===================== */
function bind(){
  $('#saveSettings').onclick = saveSettings;
  $('#refreshModels').onclick = () => {
    if (!state.endpoint) {
      toast('Please configure endpoint first');
      return;
    }
    checkApiKeyAvailability().then(() => {
      return populateModelDropdown();
    }).then(() => {
      toast('Models refreshed');
    }).catch((error) => {
      console.error('Error refreshing models:', error);
      toast('Failed to refresh models');
    });
  };
  $('#checkAll').onclick = analyseDebounced;
  $('#applyAll').onclick = applyAll;
  $('#undoBtn').onclick = undo;
  $('#rewriteSimple').onclick = ()=>doRewrite('simplify');
  $('#rewriteFormal').onclick = ()=>doRewrite('formal');
  $('#rewriteFriendly').onclick = ()=>doRewrite('friendly');
  $('#exportBtn').onclick = exportMarkdown;
  $('#copyBtn').onclick = copyToClipboard;
  $('#pasteBtn').onclick = pasteClean;
  $('#clearBtn').onclick = ()=>{ setText(''); state.suggestions={grammar:[],clarity:[],tone:[],rewrite:[]}; renderSuggestions(); };

  // Tabs
  $$('.tabs .btn').forEach(b=>b.onclick=()=>{ const tab=b.dataset.tab; $$('.panel').forEach(p=>p.classList.remove('active')); $(`#panel-${tab}`).classList.add('active'); });

  // Live metrics + paste normalise + keyboard
  $('#input').addEventListener('input', updateMetrics);
  $('#input').addEventListener('paste', e=>{ setTimeout(()=>{ const t=$('#input').value; const n=normaliseText(t); if(n!==t){ $('#input').value=n; updateMetrics(); } analyseDebounced(); },0); });
  document.addEventListener('keydown', e=>{ if(e.key==='Enter' && (e.ctrlKey||e.metaKey)){ e.preventDefault(); analyseDebounced(); }});
}
function seed(){
  const demo=`I literally  think this is basically a good idea, however it was considered and then it was decided.
The colours, flavours, and textures are vibrant, delicious and memorable.
We invited product, design and operations to the workshop.
This is not only clear but also  clear.  There  are multiple   spaces. And and duplicated words.
American spelling: color organize analyze.`;
  $('#input').value=demo; updateMetrics(); analyseDebounced();
}

// Initialize application
loadSettings(); 
bind(); 
seed();

// Check API key availability and populate models after initial setup
setTimeout(() => {
  checkApiKeyAvailability().then(() => {
    if (state.endpoint) {
      return populateModelDropdown();
    }
  }).catch(() => {
    console.log('API key check failed or models fetch failed, using defaults');
  });
}, 100); // Small delay to ensure DOM is ready

/* ===================== Busy/Loading State Management ===================== */
let busyCount = 0;
function setBusy(msg = 'LLM query sent, waiting for response …') {
  busyCount++;
  document.body.classList.add('dim');
  const ov = document.getElementById('overlay');
  const m  = document.getElementById('overlayMsg');
  if (m) m.textContent = msg;
  if (ov) ov.classList.add('show');
}
function clearBusy() {
  busyCount = Math.max(0, busyCount - 1);
  if (busyCount === 0) {
    document.body.classList.remove('dim');
    const ov = document.getElementById('overlay');
    if (ov) ov.classList.remove('show');
  }
}
</script>

<div id="overlay" class="overlay" aria-live="polite" aria-busy="true">
  <div class="card">
    <div class="spinner"></div>
    <div id="overlayMsg">LLM query sent, waiting for response …</div>
  </div>
</div>

</body>
</html>
